# Звіт про рефакторинг та аналіз SonarCloud


## 1. Таблиця метрик (До/Після)

На основі аналізу SonarCloud, ми зосередились на трьох ключових метриках, які демонструють покращення стабільності та супровідності коду.

| Метрика | До рефакторингу (Main Branch) | Після рефакторингу (Overall Code) | Результат |
| :--- | :---: | :---: | :--- |
| **Maintainability** (Code Smells) | 52 | 22 | **Покращено** (зменшено на 30) |
| **Reliability** (Bugs) | 12 | 5 | **Покращено** (зменшено на 7) |
| **Security Hotspots** | 18 | 3 | **Покращено** (зменшено на 15) |

## 2. Опис патернів рефакторингу

Було застосовано два основні підходи до покращення коду:

### Патерн 1: `Replace API / Use built-in generics (typing.Set/List → set/list)`

* **Проблема:** Виникала помилка `NameError: name 'Set' is not defined` під час імпорту модулів у тестах, оскільки використовувалися анотації типів `Set` та `List` без відповідного імпорту з модуля `typing`.
* **Рішення:** Було проведено рефакторинг коду для використання сучасних вбудованих узагальнень (generics) Python (наприклад, `typing.Set` замінено на `set`).
* **Приклад:**
    ```python
    # До
    - def _normalize(items: Iterable[str] | None) -> Set[str]:
    # Після
    + def _normalize(items: Iterable[str] | None) -> set[str]:
    ```

### Патерн 2: Покращення стійкості конфігурації (CI/App Config)

* **Проблема:** Тести в CI-пайплайні падали через невалідний `DATABASE_URL`, оскільки змінні середовища `.env` не були доступні, що призводило до помилок під час імпорту SQLAlchemy.
* **Рішення:**
    1.  Додано fallback на `sqlite:///:memory:` у `config.py`, якщо змінні оточення для PostgreSQL не задані.
    2.  Явно встановлено `DATABASE_URL: "sqlite:///:memory:"` у конфігурації CI-воркфлоу для стабільного проходження тестів.

### Патерн 3: `Extract Method (Винесення методу)`

* **Проблема:** Функція `get_attempt_with_details` мала занадто високу когнітивну складність (19/15). Вона виконувала забагато завдань: завантажувала спробу, питання, а потім у циклах групувала опції та дані для "matching", і зрештою форматувала вивід.
* **Рішення:** Складна логіка групування даних була винесена у два нових приватних методи: `_get_options_by_question` та `_get_matching_data_by_question`. Основна функція тепер лише "оркеструє" процес.

### Патерн 4: `Introduce Constant (Впровадження константи)`
* **Проблема:** "Магічний рядок" (наприклад, `"Duration of the exam in minutes"`) дублювався у кількох Pydantic-моделях (`ExamCreate`, `ExamUpdate`, `Exam`). Це ускладнює підтримку, оскільки зміна тексту вимагає редагування у трьох місцях. 
* **Рішення:** Рядок, що дублюється, був винесений в одну константу (`DURATION_MINUTES_DESC`) на рівні модуля, і всі моделі почали посилатися на неї.

### Патерн 5: `Use Modern API (Використання сучасного API)`
* **Проблема:** Метод `datetime.utcnow()` створює "наївний" об'єкт `datetime` (без часової зони), що є застарілою практикою і може призвести до помилок при порівнянні дат.
* **Рішення:** Використано сучасний підхід `datetime.now(timezone.utc)`, який створює "обізнаний" (aware) об'єкт з явно вказаною часовою зоною UTC.

#### 5.1. Заміна `datetime.utcnow()`
* **Проблема:** Метод `datetime.utcnow()` створює "наївний" об'єкт `datetime` (без часової зони), що є застарілою практикою і може призвести до помилок при порівнянні дат.
* **Рішення:** Використано сучасний підхід `datetime.now(timezone.utc)`, який створює "обізнаний" (aware) об'єкт з явно вказаною часовою зоною UTC.
* **Приклад:**
    ```python
    # До
    - from datetime import datetime
    - now = datetime.utcnow()
    # Після
    + from datetime import datetime, timezone
    + now = datetime.now(timezone.utc)
    ```

#### 5.2. Заміна `new Date().getTime()`
* **Проблема:** Конструкція `new Date().getTime()` у JavaScript створює повноцінний новий об'єкт `Date` лише для того, щоб негайно отримати з нього timestamp.
* **Рішення:** Використано статичний метод `Date.now()`, який повертає timestamp напряму, не створюючи зайвий об'єкт. Це чистіше і трохи ефективніше.
* **Приклад:**
    ```javascript
    // До
    - const nowMs = new Date().getTime()
    // Після
    + const nowMs = Date.now()
    ```

#### 5.3. Заміна `isNaN()`
* **Проблема:** Глобальна функція `isNaN()` у JavaScript виконує примусове перетворення типів перед перевіркою (наприклад, `isNaN("привіт")` поверне `true`).
* **Рішення:** Використано `Number.isNaN()`, який є суворішим і повертає `true` лише тоді, коли значення вже є числом і дорівнює `NaN`.
* **Приклад:**
    ```javascript
    // До
    - if (typeof totalSeconds !== 'number' || isNaN(totalSeconds) || totalSeconds < 0) { ... }
    // Після
    + if (typeof totalSeconds !== 'number' || Number.isNaN(totalSeconds) || totalSeconds < 0) { ... }
    ```

### Патерн 6: `Remove Unused Variable (Видалення невикористаної змінної)`

* **Проблема:** У коді тестів при розпакуванні кортежу (`call_args`) присвоювалася змінна `call_kwargs`, яка ніде далі не використовувалася, що викликало попередження лінтера.
* **Рішення:** Невикористана змінна була замінена на символ підкреслення (`_`), що є загальноприйнятою угодою в Python для ігнорування значення.
* **Приклад:**
    ```python
    # До
    - call_args, call_kwargs = mock_transcript_service.get_transcript_for_user.call_args
    # Після
    + call_args, _ = mock_transcript_service.get_transcript_for_user.call_args
    ```


## 3. Скриншоти з SonarCloud

### До рефакторингу (Main Branch)

![SonarCloud до змін](image_fc3869.png)

### Після рефакторингу (Overall Code)

![SonarCloud після змін](image_fc38aa.png)

## 4. Результати регресійного тестування

Рефакторинг був спрямований на виправлення помилок імпорту та стабілізацію тестового середовища. Тестування підтвердило, що зміни були успішними і не зламали існуючу функціональність:

* **Виправлення помилки:** Модуль `src/core/security.py` тепер імпортується без помилок `NameError`.
* **Проходження тестів (Локально):** Усі пов’язані тести (`tests/api/core/test_security_roles.py`) проходять успішно.
* **Проходження тестів (CI):** Після виправлення конфігурації CI, Pytest коректно збирає та виконує всі тести, поведінка в CI тепер узгоджена з локальним виконанням.# Звіт про рефакторинг та аналіз SonarCloud

Цей документ описує зміни, внесені для покращення якості коду, та результати аналізу в SonarCloud до і після рефакторингу.

