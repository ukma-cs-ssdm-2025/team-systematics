# Журнал дебагінгу: Тултіп виходить за межі екрану

## 1. Симптом

**Що пішло не так:**

При наведенні на іконку "!" поруч з питанням, що очікує на перевірку, з'являється спливаюча підказка (тултіп) з поясненням. Якщо це питання знаходиться біля правого або лівого краю сторінки, тултіп частково або повністю "вирізається" межами вікна перегляду (viewport). Це робить текст підказки нечитабельним і створює поганий користувацький досвід.

**Очікувана поведінка:** Тултіп повинен завжди залишатися повністю видимим, автоматично зміщуючись вліво або вправо, щоб не виходити за межі екрану.

## 2. Корінна причина (Root Cause)

**Чому це сталося:**

Проблема полягала у використанні **статичного позиціонування** за допомогою чистого CSS. Поточна реалізація центрує тултіп відносно іконки-тригера за допомогою наступних правил:

```css
.tooltip-text {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}
```

Корінна причина — це **обмеження самого CSS**, який не може приймати рішення про позиціонування на основі динамічного контексту (розміру вікна та положення елемента відносно нього). Для вирішення цієї проблеми потрібна логіка на JavaScript.

## 3. Виправлення

**Як проблему було вирішено:**

Для вирішення проблеми було створено новий, перевикористовуваний Vue-компонент `CTooltip.vue`, який інкапсулює всю логіку "розумного" позиціонування.

**Ключові аспекти реалізації:**

1.  **Компонентна структура:** `CTooltip.vue` використовує слоти (`<slot>`), що дозволяє обгортати будь-який елемент-тригер (`#trigger`) і вставляти будь-який контент (`#content`) у підказку.

2.  **Динамічний розрахунок позиції:** Основна логіка знаходиться в обробнику події `@mouseenter`.
    *   **`await nextTick()`**: Після того як тултіп стає видимим, ми чекаємо наступного "тіку" DOM, щоб гарантувати, що елемент вже відрендерений і має реальні розміри.
    *   **`getBoundingClientRect()`**: Ми отримуємо точні координати та розміри тултіпа відносно вікна перегляду.
    *   **Перевірка меж:** За допомогою простого `if/else if` ми перевіряємо, чи виходить `rect.left` за лівий край (`< 0`) або `rect.right` за правий край (`> window.innerWidth`).
    *   **Корекція стилів:** Якщо тултіп виходить за межі, ми динамічно змінюємо його inline-стилі (`tooltipEl.style.left`, `tooltipEl.style.right`, `tooltipEl.style.transform`), щоб "притиснути" його до відповідного краю екрану.

3.  **Скидання стилів:** В обробнику події `@mouseleave` ми не тільки ховаємо тултіп, але й скидаємо всі динамічно додані inline-стилі. Це гарантує, що при наступному показі розрахунки почнуться знову з початкової центральної позиції.

**Приклад коду виправлення:**
```javascript
// Всередині CTooltip.vue
async function showTooltip() {
  isVisible.value = true
  await nextTick()
  
  const tooltipEl = tooltipRef.value;
  if (!tooltipEl) return
  
  const rect = tooltipEl.getBoundingClientRect()
  
  if (rect.left < 0) {
    tooltipEl.style.left = '0'
    tooltipEl.style.transform = 'translateX(0)'
  } else if (rect.right > window.innerWidth) {
    tooltipEl.style.left = 'auto'
    tooltipEl.style.right = '0'
    tooltipEl.style.transform = 'translateX(0)'
  }
}
```

## 4. Урок

**Що б я зробила інакше наступного разу:**

**Урок:** Не варто покладатися на чистий CSS для складних завдань позиціонування, які залежать від контексту вікна перегляду.

Наступного разу, проєктуючи подібний інтерактивний елемент, я б **одразу** планувала його реалізацію як окремого, самодостатнього компонента з логікою на JavaScript. Замість того, щоб спочатку робити "просту" реалізацію на CSS, а потім переробляти її, я б з самого початку виділила час на створення універсального компонента.

Це дозволило б:
1.  **Заощадити час на рефакторингу:** Не довелося б переписувати вже написаний CSS та HTML.
2.  **Уникнути дублювання коду:** Логіка тултіпа була б одразу інкапсульована в одному місці, а не розкидана по різних компонентах.
3.  **Миттєво отримати гнучке рішення:** Універсальний компонент можна було б одразу використовувати в інших частинах додатку, не турбуючись про крайові випадки.


