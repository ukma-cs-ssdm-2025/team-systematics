# Стратегія Тестування (Testing Strategy)

План тестування та розвитку проєкту Systematics.

---

## 1. Поточний статус тестування

Проєкт вже має фундамент автоматизованих тестів, які покривають ключові частини коду. Тестування розділене за рівнями відповідальності:

* **Модульне тестування (Unit Tests):**
    * **Утиліти:** Базові функції, такі як хешування паролів та обробка рядків (наприклад `test_hashing.py`). Тести перевіряють основний функціонал та обробку граничних випадків (наприклад UTF-8, обрізка до 72 байт).
    * **Сервісний рівень:** Бізнес-логіка (наприклад `AuthService`) тестується з використанням моків для шару репозиторію. Це перевіряє, що логіка автентифікації (наприклад "User not found", "Invalid password") та формування відповіді працюють правильно.

* **Інтеграційне тестування (Integration Tests):**
    * **Рівень API (Контролери):** API-ендпоїнти (наприклад `AuthController`) тестуються за допомогою `TestClient`. Ці тести перевіряють маршрутизацію, валідацію вхідних даних (Pydantic) та коректність HTTP-відповідей (статус-коди 200, 401, 422). Сервісний шар на цьому рівні наразі імітується.

---

## 2. Плани щодо типів тестування

Для забезпечення якості ми розширимо покриття, додавши наступні типи тестів:

### Інтеграційні тести (з реальною БД)

* **План:** Поточні інтеграційні тести на рівні API будуть розширені для роботи з реальною тестовою базою даних, а не моками. Ми будемо використовувати Docker-контейнер PostgreSQL для запуску тестів у чистому, тимчасовому середовищі.
* **Мета:** Перевірити коректність SQL-запитів, роботу ORM (SQLAlchemy) та цілісність даних на рівні схем.

### Системні (End-to-End) тести

* **План:** Впровадити E2E-тести, які повністю симулюють шлях користувача: від взаємодії з інтерфейсом у `client` до отримання відповіді від API та перевірки змін у базі даних.
* **Приклад сценарію:** "Користувач відкриває сторінку логіну, вводить дані, натискає 'Увійти', бачить своє ім'я на головній сторінці".
* **Інструменти:** Cypress або Playwright для автоматизації браузера.

### Приймальні тести (Acceptance Tests)

* **План:** Сформулювати набір формальних тест-кейсів на основі історій користувачів (User Stories) або вимог.
* **Процес:** Перед кожним релізом проводити ручне (або частково автоматизоване) тестування за цими сценаріями для підтвердження, що функціонал відповідає очікуванням замовника.

---

## 3. Плани щодо тестування продуктивності та безпеки

### Тестування продуктивності (Performance Testing)

* **План:** Створити базові навантажувальні тести для критичних ендпоїнтів, насамперед `/api/auth/login` та ключових запитів до екзаменів.
* **Мета:** Визначити базову продуктивність (кількість запитів на секунду) та переконатися, що час відповіді не деградує з часом.
* **Інструменти:** `k6` або `locust`.

### Тестування безпеки (Security Testing)

* **План:** До поточних тестів на аутентифікацію додати перевірки на базові вразливості:
    1.  Перевірка прав доступу (користувач не може отримати дані іншого користувача).
    2.  Захист від SQL-ін'єкцій (перевірка, що ORM коректно параметризує запити).
    3.  Перевірка, що у відповідях про помилки не розкривається чутлива інформація (наприклад, повні шляхи до файлів або тексти SQL-помилок).

### Property-Based Тестування

* **План (Майбутній):** Для складних функцій (наприклад підрахунок результатів тестів, обробка даних) розглянути впровадження property-based тестів (з використанням `hypothesis`) для перевірки логіки на широкому діапазоні неочікуваних вхідних даних.

---

## 4. Інтеграція з CI/CD

Автоматизовані тести будуть інтегровані у наш pipeline безперервної інтеграції та доставки (CI/CD), який налаштований у `.github/workflows`. Це гарантуватиме, що кожна зміна коду перевіряється автоматично перед тим, як потрапити до основної гілки або бути розгорнутою.