# Проблеми надійності

## A. Обробка помилок

### 1. Відсутність обробки помилок для непередбачених ситуацій

- Проблема:
У коді є обробка помилок для визначених типів помилок, але немає обробки непередбачених помилок, які можуть виникнути під час виконання програми.

- Код (фрагмент):
```python
@app.exception_handler(AppError)
async def app_error_handler(_: Request, exc: AppError):
    return exc.to_response()
```

- Чому вона небезпечна:
Якщо у програмі виникне непередбачена помилка (наприклад, проблема з підключенням до бази даних, помилка при серіалізації даних тощо), ця помилка не буде оброблена явно і може призвести до непередбачуваних наслідків (наприклад, крах сервера).

- Потенційний вплив:

| Поле | Значення |
|------|----------|
| **Fault** | Відсутність обробника для непередбачених винятків у `install_exception_handlers`. |
| **Error** | Непередбачені винятки не обробляються, що може призвести до некоректного внутрішнього стану системи. |
| **Failure** | Сервер може крашнути або повернути некоректну відповідь користувачу. |
| **Severity** | High, оскільки це може призвести до зупинки або некоректної роботи додатку. |

### 2. Занадто широке перехоплення помилок

- Проблема:
Обробка виключень за допомогою Exception у функціях типу `starlette_exc_handler` може призвести до перехоплення більшості виключень, включаючи системні помилки, які не повинні бути приховані від користувача.

- Код (фрагмент):
```python
@app.exception_handler(StarletteHTTPException)
async def starlette_exc_handler(_: Request, exc: StarletteHTTPException):
    return JSONResponse(status_code=exc.status_code, content={
        "error": {"code": code, "message": str(exc.detail), "details": None}
    })
```

- Чому вона небезпечна:
Перехоплення усіх помилок без їх адекватного розрізнення може приховати важливі повідомлення про помилки, які мають бути опрацьовані окремо (наприклад, помилки конфігурації чи помилки сервера). Це також може створити ситуацію, коли помилки не будуть належним чином логуватись або досліджуватись.

- Потенційний вплив:

| Поле | Значення |
|------|----------|
| **Fault** | Занадто загальна обробка помилок без розрізнення типів у `starlette_exc_handler`. |
| **Error** | Різні типи помилок обробляються однаково, що може призвести до втрати важливої інформації про помилки. |
| **Failure** | Користувач може отримати некоректні або неінформативні повідомлення про помилки. |
| **Severity** | Medium, оскільки важливі системні помилки можуть бути приховані. |

### 3. Небезпечні повідомлення користувачу (витік внутрішніх деталей)

- Проблема:
У разі деяких помилок повідомлення, що надаються користувачам, можуть містити внутрішні деталі, які не повинні бути доступні зовнішнім користувачам (наприклад, стек трасування помилки).

- Код (фрагмент):
```python
@app.exception_handler(StarletteHTTPException)
async def starlette_exc_handler(_: Request, exc: StarletteHTTPException):
    return JSONResponse(status_code=exc.status_code, content={
        "error": {"code": code, "message": str(exc.detail), "details": None}
    })
```

- Чому вона небезпечна:
Приклад вищезгаданого коду може показувати внутрішні деталі помилки (наприклад, стек помилки або `str(exc.detail)`), що може бути використано для атаки (наприклад, відомості про структуру додатку або уразливості).

- Потенційний вплив:

| Поле | Значення |
|------|----------|
| **Fault** | Використання `str(exc.detail)` без фільтрації внутрішніх деталей у обробниках помилок. |
| **Error** | Внутрішні деталі помилок (стеки, шляхи файлів) потрапляють у внутрішній стан системи. |
| **Failure** | Користувач бачить внутрішні деталі системи, що може бути використано для атаки. |
| **Severity** | High, оскільки це може допомогти зловмисникам знайти вразливості. |

### 4. Відсутність обробки помилок у route handlers

- Проблема:
Деякі route handlers не мають обробки помилок, що може призвести до непередбачених крашів сервера.

- Код (фрагмент):
```python
@self.router.get("/{exam_id}", response_model=Exam, summary="Get exam by id")
async def get_exam(exam_id: UUID, db: Session = Depends(get_db)):
    return self.service.get(db, exam_id)
```

- Чому вона небезпечна:
Якщо виникне помилка під час виконання запиту до БД або обробки даних, сервер може крашнути або повернути некоректну відповідь без належного повідомлення про помилку.

- Потенційний вплив:

| Поле | Значення |
|------|----------|
| **Fault** | Відсутність блоків try/except у route handler `get_exam`. |
| **Error** | Необроблені винятки можуть призвести до некоректного внутрішнього стану системи. |
| **Failure** | Сервер може крашнути або повернути некоректну відповідь користувачу. |
| **Severity** | High, оскільки це може призвести до крашів сервера або некоректної поведінки. |

## B. Зовнішні залежності

### 5. Виклики БД без таймаутів

- Проблема:
Підключення до бази даних не мають налаштувань таймаутів, що може призвести до зависання запитів на невизначений час.

- Код (фрагмент):
```python
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
```

- Чому вона небезпечна:
Без таймаутів запити до БД можуть зависати на невизначений час, блокувати потоки обробки запитів та призводити до відмови в обслуговуванні.

- Потенційний вплив:

| Поле | Значення |
|------|----------|
| **Fault** | Відсутність параметрів `connect_timeout` та `statement_timeout` у `create_engine`. |
| **Error** | Запити до БД можуть зависати на невизначений час, блокувати потоки обробки. |
| **Failure** | Система може перестати обробляти запити, що призводить до DoS. |
| **Severity** | High, оскільки це може призвести до DoS через зависання запитів. |

### 6. Файлові операції без валідації та таймаутів

- Проблема:
Завантаження файлів у Cloudinary не має валідації розміру файлу, типу файлу та таймаутів, що може призвести до проблем з безпекою та продуктивністю.

- Код (фрагмент):
```python
try:
    upload_result = cloudinary.uploader.upload(
        file.file,
        public_id=public_id,
        overwrite=True,
    )
except cloudinary.exceptions.Error as e:
    raise HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail=f"Failed to upload image: {str(e)}"
    )
```

- Чому вона небезпечна:
Без валідації розміру та типу файлу можна завантажити великі файли або файли небезпечних типів, що може призвести до DoS атаки або виконання шкідливого коду. Відсутність таймаутів може призвести до зависання операцій завантаження.

- Потенційний вплив:

| Поле | Значення |
|------|----------|
| **Fault** | Відсутність перевірки розміру файлу, типу файлу та параметра `timeout` у `cloudinary.uploader.upload`. |
| **Error** | Система може прийняти великі або небезпечні файли, операції завантаження можуть зависати. |
| **Failure** | Користувач може завантажити файли, що призводять до DoS атаки або проблем з безпекою. |
| **Severity** | High, оскільки це може призвести до DoS атаки або проблем з безпекою. |

## C. Валідація вхідних даних

### 7. Нульові або порожні значення не перевіряються

- Проблема:
Методи репозиторіїв не перевіряють вхідні параметри на null або порожні значення перед виконанням запитів до БД.

- Код (фрагмент):
```python
def get(self, exam_id: UUID) -> Optional[Exam]:
    return self.db.query(Exam).filter(Exam.id == exam_id).first()
```

- Чому вона небезпечна:
Передача None або порожніх значень може призвести до некоректних запитів до БД, помилок виконання або непередбаченої поведінки.

- Потенційний вплив:

| Поле | Значення |
|------|----------|
| **Fault** | Відсутність перевірки на `None` або порожні значення перед виконанням запитів у методі `get`. |
| **Error** | Передача `None` може призвести до некоректних запитів до БД та помилок виконання. |
| **Failure** | Система може повернути некоректний результат або викинути помилку користувачу. |
| **Severity** | Medium, оскільки це може призвести до помилок виконання або некоректної поведінки. |

### 8. Відсутня перевірка типів

- Проблема:
Метод `create_question` приймає `dict` без перевірки типів вкладених структур даних, що може призвести до помилок під час виконання.

- Код (фрагмент):
```python
def create_question(self, exam_id: UUID, payload) -> Question:
    question_data = {k: v for k, v in payload.items() if k not in ('options', 'matching_data')}
    q = Question(**question_data)
    # ...
    options = payload.get('options') or []
    for opt in options:
        o = Option(question_id=q.id, text=opt.get('text'), is_correct=opt.get('is_correct', False))
```

- Чому вона небезпечна:
Без перевірки типів можна передати некоректні дані, що призведе до помилок під час виконання або некоректної поведінки програми.

- Потенційний вплив:

| Поле | Значення |
|------|----------|
| **Fault** | Відсутність перевірки типів (`isinstance`) для `payload`, `options`, `matching_data` у методі `create_question`. |
| **Error** | Передача некоректних типів може призвести до помилок під час виконання (AttributeError, TypeError). |
| **Failure** | Система може крашнути або повернути некоректну помилку користувачу. |
| **Severity** | Medium, оскільки це може призвести до помилок виконання або некоректної поведінки. |

## D. Потенційні "silent failures"

### 9. Повернення None без логування

- Проблема:
Методи репозиторіїв повертають `None` без логування, що ускладнює діагностику проблем.

- Код (фрагмент):
```python
def update_question(self, question_id: UUID, patch: dict) -> Optional[Question]:
    q = self.db.query(Question).filter(Question.id == question_id).first()
    if not q:
        return None
```

- Чому вона небезпечна:
Без логування важко діагностувати проблеми, коли методи повертають `None`. Це може призвести до "silent failures", коли помилки не виявляються.

- Потенційний вплив:

| Поле | Значення |
|------|----------|
| **Fault** | Відсутність викликів `logger.warning()` або `logger.debug()` при поверненні `None` у методах репозиторіїв. |
| **Error** | Відсутність логів ускладнює виявлення причин повернення `None`, проблеми залишаються невидимими. |
| **Failure** | Користувач може отримати некоректну поведінку без зрозумілих причин, діагностика проблем ускладнена. |
| **Severity** | Medium, оскільки це ускладнює діагностику проблем. |

### 10. Непередбачена поведінка замість чіткої помилки

- Проблема:
Метод `_run_fast_tfidf_filter` повертає порожній список при помилці без логування, що може приховати проблеми.

- Код (фрагмент):
```python
def _run_fast_tfidf_filter(...) -> List[Dict[str, Any]]:
    corpus = [base_text] + candidate_texts
    vectorizer = TfidfVectorizer()
    try:
        tfidf_matrix = vectorizer.fit_transform(corpus)
    except ValueError:
        # Наприклад, якщо всі тексти порожні або надто короткі
        return []
```

- Чому вона небезпечна:
Без логування помилок важко зрозуміти, чому операція не вдалася. Це може приховати реальні проблеми та ускладнити діагностику.

- Потенційний вплив:

| Поле | Значення |
|------|----------|
| **Fault** | Відсутність викликів `logger.warning()` при обробці винятків у методі `_run_fast_tfidf_filter`. |
| **Error** | Помилки привекторизації TF-IDF не логуються, що ускладнює виявлення проблем. |
| **Failure** | Система може повернути порожній результат без зрозумілих причин для користувача. |
| **Severity** | Medium, оскільки це ускладнює діагностику проблем. |

## E. Продуктивність і блокування

### 11. Довгі операції у request handler

- Проблема:
Метод `check_attempt` у `PlagiarismService` виконує довгі обчислювальні операції без обмеження часу, що може призвести до блокування обробки запитів.

- Код (фрагмент):
```python
def check_attempt(self, db: Session, attempt: Attempt) -> PlagiarismReport:
    base_text = self._build_attempt_text(db, attempt.id)
    # ... довгі операції без обмеження часу
    deep_matches, _ = self._run_deep_semantic_analysis(db, base_text, fast_matches)
```

- Чому вона небезпечна:
Довгі операції без обмеження часу можуть блокувати обробку інших запитів, що призводить до погіршення продуктивності та можливості DoS атаки.

- Потенційний вплив:

| Поле | Значення |
|------|----------|
| **Fault** | Відсутність перевірки часу виконання та обмеження `MAX_PROCESSING_TIME` у методі `check_attempt`. |
| **Error** | Довгі операції можуть блокувати потоки обробки запитів на невизначений час. |
| **Failure** | Система може перестати обробляти інші запити, що призводить до DoS. |
| **Severity** | High, оскільки це може призвести до блокування обробки запитів та DoS. |

### 12. Відсутність обробки помилок у довгих операціях

- Проблема:
Довгі операції у `check_attempt` не мають належної обробки помилок, що може призвести до крашів або некоректної поведінки.

- Код (фрагмент):
```python
def check_attempt(self, db: Session, attempt: Attempt) -> PlagiarismReport:
    base_text = self._build_attempt_text(db, attempt.id)
    # ... операції без обробки помилок
    deep_matches, _ = self._run_deep_semantic_analysis(db, base_text, fast_matches)
    # ... якщо виникне помилка, метод може крашнути
```

- Чому вона небезпечна:
Без обробки помилок довгі операції можуть крашнути, що призведе до втрати даних або некоректної поведінки системи.

- Потенційний вплив:

| Поле | Значення |
|------|----------|
| **Fault** | Відсутність блоку `try/except` для обробки винятків у методі `check_attempt`. |
| **Error** | Необроблені винятки можуть призвести до втрати даних або некоректного внутрішнього стану системи. |
| **Failure** | Система може крашнути під час перевірки на плагіат, користувач не отримає результат. |
| **Severity** | High, оскільки це може призвести до крашів та втрати даних. |

